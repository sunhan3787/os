无锁CAS，无锁队列
队列放入和读取过于频繁
volatile 修饰变量+
type __sync_val_compare_and_swap (type *ptr, type oldval type newval)
compare and swap;比较内存有没有被修改，期望值和读出来的值是否一致
应用：无锁队列，ZMQ中的设计用到了cas无锁队列； disruptor库
涉及到cache的操作的问题：每个CPU都有独立的cache, cache修改了，cache1和cache2会失效的问题；
缺点：出了问题很难debug；考验设计能力；
mutex
如果获取不到锁，线程就会进入休眠，让出CPU资源，线程加入到所等待队列中；
缺点：切换上下文引起的效率的问题；要避免频繁的切换上下文成为应用场景的选择；
临界区执行代码比较长时mutex和spinlock相比较会占优势一点；比如：for(i =0 ;i <10000;i++){sum++;}
Spinlock自旋锁：
忙等待，继续去检测锁的状态；
应用场景中：1.临界区内不能存在阻塞；2，临界区代码段执行时间不能过长，比如：i++;++i......；

++i;i++;
1.把i从内存加载到寄存器；
2.执行操作；
3.写回内存；

gcc -S Filenale.c
Vim Filenam.s
其反汇编代码：
movl  i(%rip),  %eax
addl  $1,  %eax
movl  %eax,  i(%rip)

原子操作指令API:add,sub,or,and,xor,nand

X86内存汇编指令加操作：lxx_atomic_add(&s_i, 1);
static int lxx_atomic_add(int *ptr, int increment) 
{ 
int old_value = *ptr; 
 __asm__ volatile("lock; xadd %0, %1 \n\t" 
: "=r"(old_value), "=m"(*ptr) 
: "0"(increment), "m"(*ptr) 
: "cc", "memory"); 
return *ptr; 
}

C++11：atomic

死锁与活锁：
解决活锁：先来先服务
解决死锁：预防：一次封锁法权、顺序封锁法
1.死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
2.活锁：线程A和B都需要过桥(都需要使用进程),而都礼让不走(那到的系统优先级相同,都认为不是自己优先级高),导致的进程无法向前推进.

活锁和死锁的区别：处于活锁的实体是在不断的改变状态，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。

饥饿，是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况。饥饿是由资源分配策略决定的，可以通过先来先服务等资源分配策略来避免。

产生死锁的四个必要条件：
<1.>资源互斥使用：资源独占，同一时刻资源只能被一个进程使用；
<2.>请求与保持：进程在申请新的资源的同时，保持对原有资源的占有；
<3.>不可剥夺：资源只能由占有者自己释放；
<4.>循环等待：P1等待P2占有的资源，P2等待P3的资源，...Pn等待P1的资源，形成一个进程等待回路；





