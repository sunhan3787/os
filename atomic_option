线程同步
同步：同步控制着线程之间的执行顺序，不让他们抢占式执行。
在保证数据安全的前提下，让线程能够按照某种特定的顺序访问临界资源，从而有效避免饥饿问题，叫做同步。
原子访问：同一时刻，只允许一个线程访问临界资源；
原子操作：指多步操作组成的一个操作；原子操作中线程不会被切换，线程切换要么在原子操作之前，要么在原子操作完成之后。
在单核系统里，单个的机器指令可以看成是原子操作（如果有编译器优化、乱序执行等情况除外）；
在多核系统中，单个的机器指令就不是原子操作，因为多核系统里是多指令流并行运行的，一个核在执行一个指令时，其他核同时执行的指令有可能操作同一块内存区域，从而出现数据竞争现象。
多核系统中的原子操作通常使用内存栅障（memory barrier）来实现，即一个CPU核在执行原子操作时，其他CPU核必须停止对内存操作或者不对指定的内存进行操作，这样才能避免数据竞争问题。

无锁CAS，无锁队列
队列放入和读取过于频繁
volatile 修饰变量+
type __sync_val_compare_and_swap (type *ptr, type oldval type newval)
compare and swap;比较内存有没有被修改，期望值和读出来的值是否一致
应用：无锁队列，ZMQ中的设计用到了cas无锁队列； disruptor库
涉及到cache的操作的问题：每个CPU都有独立的cache, cache修改了，cache1和cache2会失效的问题；
缺点：出了问题很难debug；考验设计能力；
mutex
如果获取不到锁，线程就会进入休眠，让出CPU资源，线程加入到所等待队列中；
缺点：切换上下文引起的效率的问题；要避免频繁的切换上下文成为应用场景的选择；
临界区执行代码比较长时mutex和spinlock相比较会占优势一点；比如：for(i =0 ;i <10000;i++){sum++;}
Spinlock自旋锁：
忙等待，继续去检测锁的状态；
应用场景中：1.临界区内不能存在阻塞；2，临界区代码段执行时间不能过长，比如：i++;++i......；

++i;i++;
1.把i从内存加载到寄存器；
2.执行操作；
3.写回内存；

gcc -S Filenale.c
Vim Filenam.s
其反汇编代码：
movl  i(%rip),  %eax
addl  $1,  %eax
movl  %eax,  i(%rip)

原子操作指令API:add,sub,or,and,xor,nand

X86内存汇编指令加操作：lxx_atomic_add(&s_i, 1);
static int lxx_atomic_add(int *ptr, int increment) 
{ 
int old_value = *ptr; 
 __asm__ volatile("lock; xadd %0, %1 \n\t" 
: "=r"(old_value), "=m"(*ptr) 
: "0"(increment), "m"(*ptr) 
: "cc", "memory"); 
return *ptr; 
}

C++11提供了原子操作：atomic

悲观锁: 在每次取数据时，总是担心数据会被其他线程修改，所以会在取数据前先加锁(读锁，写锁， 行锁等)，当其他线程想要访问数据时，被阻塞挂起。
乐观锁: 每次取数据时候，总是乐观的认为数据不会被其他线程修改，因此不上锁。但是在更新数据 前，会判断其他数据在更新前有没有对数据进行修改。主要采用两种方式:版本号机制和CAS操作。
CAS操作: 当需要更新数据时，判断当前内存值和之前取得的值是否相等。如果相等则用新值更新。若 不等则失败，失败则重试，一般是一个自旋的过程，即不断重试。

死锁与活锁：
解决活锁：先来先服务
解决死锁：预防：一次封锁法权、顺序封锁法
1.死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
2.活锁：线程A和B都需要过桥(都需要使用进程),而都礼让不走(那到的系统优先级相同,都认为不是自己优先级高),导致的进程无法向前推进.

活锁和死锁的区别：处于活锁的实体是在不断的改变状态，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。

饥饿，是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况。饥饿是由资源分配策略决定的，可以通过先来先服务等资源分配策略来避免。

产生死锁的四个必要条件：
<1.>资源互斥使用：资源独占，同一时刻资源只能被一个进程使用；
<2.>请求与保持：进程在申请新的资源的同时，保持对原有资源的占有；
<3.>不可剥夺：资源只能由占有者自己释放；
<4.>循环等待：P1等待P2占有的资源，P2等待P3的资源，...Pn等待P1的资源，形成一个进程等待回路；



